import React, { useState, useEffect, useRef, useCallback } from 'react';
import * as Tone from 'tone';
import SynthSelector from '../synth/SynthSelector';
import ChordBank from '../synth/ChordBank';
import StopButton from '../synth/StopButton';
import ParticleSystem from '../synth/ParticleSystem';
import Timeline from '../synth/Timeline';
import PianoRoll from '../synth/PianoRoll';
import { midiToFreq, findOptimalVoicing } from '../../utils/noteUtils';
import { createSynth, disposeSynth } from '../../utils/synthUtils';
import { sendMIDIChord, allNotesOff } from '../../utils/midiUtils';
import { getPresetById } from '../../utils/presets';
import useEffectsChain from '../../hooks/useEffectsChain';
import useMIDISetup from '../../hooks/useMIDISetup';
import './SynthesizerContainer.css';

// Determine the mode based on chord progression
const determineMode = (chords) => {
  // Filter out null chords
  const validChords = chords.filter(chord => chord !== null);
  if (validChords.length === 0) return 'ionian'; // Default to major/ionian

  // Count occurrences of each root note
  const rootCounts = {};
  validChords.forEach(chord => {
    const root = chord.note.replace(/[0-9]/g, ''); // Remove octave number
    rootCounts[root] = (rootCounts[root] || 0) + 1;
  });
  
  // Find most common root (potential tonic)
  let tonic = Object.keys(rootCounts).reduce((a, b) => 
    rootCounts[a] > rootCounts[b] ? a : b, Object.keys(rootCounts)[0]);
  
  // Simple heuristic for mode detection based on chord qualities
  // Analyze for minor chords to detect potential minor modes
  const minorChords = validChords.filter(chord => 
    chord.name.includes('m') && !chord.name.includes('maj'));
  
  if (minorChords.length > validChords.length / 2) {
    // More minor chords, likely a minor mode
    // Check if vi chord is present (relative minor)
    const relativeMinorPresent = validChords.some(chord => {
      const relativeMinor = getRelativeMinor(tonic);
      return chord.note.startsWith(relativeMinor);
    });
    
    if (relativeMinorPresent) {
      return 'aeolian'; // Natural minor
    } else {
      // Check for other minor modes
      return 'dorian'; // Default to Dorian if unsure
    }
  } else {
    // More major chords, likely a major mode
    return 'ionian'; // Major scale
  }
};

// Get relative minor for a major key
const getRelativeMinor = (majorKey) => {
  const majorKeys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const minorKeys = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
  
  const index = majorKeys.indexOf(majorKey);
  if (index !== -1) {
    return minorKeys[index];
  }
  return 'A'; // Default
};

// Get scale notes based on root and mode
const getScaleNotes = (root, mode) => {
  // Define intervals for different modes (steps from root)
  const modeIntervals = {
    ionian:   [0, 2, 4, 5, 7, 9, 11], // Major scale
    dorian:   [0, 2, 3, 5, 7, 9, 10], // Dorian mode
    phrygian: [0, 1, 3, 5, 7, 8, 10], // Phrygian mode
    lydian:   [0, 2, 4, 6, 7, 9, 11], // Lydian mode
    mixolydian: [0, 2, 4, 5, 7, 9, 10], // Mixolydian mode
    aeolian:  [0, 2, 3, 5, 7, 8, 10], // Natural minor
    locrian:  [0, 1, 3, 5, 6, 8, 10]  // Locrian mode
  };
  
  // Define all notes
  const allNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  
  // Find root index
  const rootIndex = allNotes.indexOf(root.replace(/[0-9]/g, ''));
  if (rootIndex === -1) return []; // Invalid root
  
  // Get intervals for the mode
  const intervals = modeIntervals[mode] || modeIntervals.ionian;
  
  // Generate scale notes
  return intervals.map(interval => {
    const noteIndex = (rootIndex + interval) % 12;
    return allNotes[noteIndex];
  });
};

// Extract chord notes based on chord name
const getChordNotes = (chordName) => {
  // Simple parsing of common chord types
  const root = chordName.replace(/[0-9]/g, '').match(/^[A-G][#b]?/)[0];
  const chordType = chordName.replace(/[0-9]/g, '').replace(/^[A-G][#b]?/, '');
  
  // Define intervals for common chord types
  const chordIntervals = {
    '': [0, 4, 7],         // Major
    'm': [0, 3, 7],        // Minor
    '7': [0, 4, 7, 10],    // Dominant 7
    'maj7': [0, 4, 7, 11], // Major 7
    'm7': [0, 3, 7, 10],   // Minor 7
    'dim': [0, 3, 6],      // Diminished
    'aug': [0, 4, 8]       // Augmented
  };
  
  // Get intervals for this chord type
  let intervals = [0, 4, 7]; // Default to major
  for (const [type, typeIntervals] of Object.entries(chordIntervals)) {
    if (chordType === type) {
      intervals = typeIntervals;
      break;
    }
  }
  
  // Define all notes
  const allNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  
  // Find root index
  const rootIndex = allNotes.indexOf(root);
  if (rootIndex === -1) return []; // Invalid root
  
  // Generate chord notes
  return intervals.map(interval => {
    const noteIndex = (rootIndex + interval) % 12;
    return allNotes[noteIndex];
  });
};

const SynthesizerContainer = ({ 
  isWizardMode = false,
  sectionTitle,
  sectionDescription 
}) => {
  // State management
  const [previousNotes, setPreviousNotes] = useState(null);
  const [previousSynth, setPreviousSynth] = useState(null);
  const [synth, setSynth] = useState(null);
  const [leadSynth, setLeadSynth] = useState(null); // New lead synth for the piano roll pattern
  const [selectedSynth, setSelectedSynth] = useState('polysynth');
  const [selectedPreset, setSelectedPreset] = useState('atmospheric');
  const [isPlayingSequence, setIsPlayingSequence] = useState(false);
  const [audioContextStarted, setAudioContextStarted] = useState(false);
  const [audioContextInitialized, setAudioContextInitialized] = useState(false);
  const [wizardStep, setWizardStep] = useState(1);
  const [songName, setSongName] = useState('');
  const [trackName, setTrackName] = useState('');
  const sequenceRef = useRef(null);
  const patternPlaybackRef = useRef(null); // Reference for pattern playback
  const effectsChainRef = useRef(null);
  const [effectsChain, setEffectsChain] = useState(null);
  const [timelineChords, setTimelineChords] = useState([null, null, null, null]);
  const [pianoRollNotes, setPianoRollNotes] = useState([]);
  const [activeNotes, setActiveNotes] = useState([]);
  const [currentSequenceIndex, setCurrentSequenceIndex] = useState(-1);
  const [patternPlaybackPosition, setPatternPlaybackPosition] = useState(-1); // Position for pattern playback
  const [particleProps, setParticleProps] = useState({
    active: false,
    position: { x: 0, y: 0 },
    color: '#6C63FF',
    mode: 'ambient'
  });

  // Custom hooks
  const { 
    midiOutput, 
    midiOutputs, 
    selectedPort, 
    handleMidiDeviceChange 
  } = useMIDISetup();

  // Update refs when dependencies change
  useEffect(() => {
    effectsChainRef.current = effectsChain;
  }, [effectsChain]);

  useEffect(() => {
    synthRef.current = synth;
  }, [synth]);

  // Define initializeAudioContext outside of any useEffect
  const initializeAudioContext = async () => {
    try {
      // Check if we already tried to initialize
      if (audioContextInitialized) return;
      
      // Initialize Tone.js context safely
      if (Tone.context.state !== "running") {
        console.log("Initializing Tone.js audio context");
        await Tone.start();
        setAudioContextStarted(true);
      } else {
        setAudioContextStarted(true);
      }
      setAudioContextInitialized(true);
    } catch (error) {
      console.error("Error initializing audio context:", error);
    }
  };

  // Initialize audio context properly
  useEffect(() => {
    // Add event listeners to initialize context on user interaction
    const handleUserInteraction = () => {
      if (!audioContextInitialized) {
        initializeAudioContext();
      }
    };

    window.addEventListener('click', handleUserInteraction);
    window.addEventListener('keydown', handleUserInteraction);
    window.addEventListener('touchstart', handleUserInteraction);

    return () => {
      // Clean up event listeners
      window.removeEventListener('click', handleUserInteraction);
      window.removeEventListener('keydown', handleUserInteraction);
      window.removeEventListener('touchstart', handleUserInteraction);
    };
  }, [audioContextInitialized, initializeAudioContext]);

  // Update initialization to ensure atmospheric preset is loaded
  useEffect(() => {
    // Initialize the audio context on component mount
    const initializeComponent = async () => {
      await initializeAudioContext();
      
      // Force atmospheric preset initialization
      handlePresetChange({ target: { value: 'atmospheric' } });
    };

    initializeComponent();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Initialize synthesizer when selected synth changes
  useEffect(() => {
    if (effectsChain) {
      try {
        handleSynthChange({ target: { value: selectedSynth } });
      } catch (error) {
        console.error("Error initializing synth:", error);
      }
    }
  }, [effectsChain, selectedSynth]);

  // Clean up synth on unmount
  useEffect(() => {
    return () => {
      if (synth) {
        try {
          disposeSynth(synth);
        } catch (error) {
          console.error("Error disposing synth:", error);
        }
      }
      
      // Clean up sequencer if it's running
      if (sequenceRef.current) {
        clearInterval(sequenceRef.current);
      }
    };
  }, [synth]);

  // Handle synth type change
  const handleSynthChange = (event) => {
    try {
      const type = event.target.value;
      console.log("Changing synthesizer to:", type);
      setSelectedSynth(type);
      
      if (!type) {
        console.warn("No synth type provided");
        return;
      }

      // Dispose of previous synth if it exists
      if (synth) {
        console.log("Disposing previous synth:", selectedSynth);
        try {
          disposeSynth(synth);
        } catch (error) {
          console.error("Error disposing previous synth:", error);
        }
      }
      
      // Make sure effects chain is initialized
      if (!effectsChainRef.current) {
        console.warn("Effects chain not initialized");
        return;
      }
      
      let newSynth;
      
      // Create new synth using our utility function
      if (type === 'polysynth') {
        console.log("Creating new polysynth");
        try {
          newSynth = createSynth(type, effectsChainRef.current);
          
          // Automatically show synth controls for polysynth
          // setShowSynthControls(true);
          
          // Apply preset parameters based on selected preset
          if (newSynth) {
            console.log("Applying preset parameters from:", selectedPreset);
            setTimeout(() => {
              try {
                // Apply preset using the handlePresetChange function
                const presetEvent = { target: { value: selectedPreset } };
                handlePresetChange(presetEvent);
              } catch (error) {
                console.error("Error applying preset parameters:", error);
              }
            }, 100); // Small delay to ensure synth is fully created
          }
        } catch (error) {
          console.error("Error creating synth:", error);
          newSynth = null;
        }
      } else {
        console.log("Setting up MIDI mode");
        newSynth = null;
        // Hide synth controls for MIDI
        // setShowSynthControls(false);
      }

      setSynth(newSynth);
      console.log("Synth updated to:", type);
    } catch (error) {
      console.error("Error in handleSynthChange:", error);
    }
  };
  
  // Handle preset changes
  const handlePresetChange = (event) => {
    const presetId = event.target.value;
    setSelectedPreset(presetId);
    
    // If we have an active synth, apply the preset parameters and effects
    if (synth && !synth._disposed && presetId) {
      try {
        const preset = getPresetById(presetId);
        console.log(`Applying preset: ${preset.name}`);
        
        // Apply synth parameters
        if (preset.synthParams) {
          Object.entries(preset.synthParams).forEach(([paramKey, paramValue]) => {
            if (typeof paramValue === 'object') {
              // Handle nested objects like oscillator.type
              Object.entries(paramValue).forEach(([nestedKey, nestedValue]) => {
                try {
                  synth.set({ [paramKey]: { [nestedKey]: nestedValue } });
                } catch (paramError) {
                  console.warn(`Error setting nested param ${paramKey}.${nestedKey}:`, paramError);
                }
              });
            } else {
              // Handle direct parameters
              try {
                synth.set({ [paramKey]: paramValue });
              } catch (paramError) {
                console.warn(`Error setting param ${paramKey}:`, paramError);
              }
            }
          });
        }
        
        // Apply effects
        if (preset.effects && effectsChainRef.current) {
          Object.entries(preset.effects).forEach(([effectType, effectParams]) => {
            const effect = effectsChainRef.current.getEffect(effectType);
            if (effect) {
              Object.entries(effectParams).forEach(([paramKey, paramValue]) => {
                try {
                  effect.set({ [paramKey]: paramValue });
                } catch (effectError) {
                  console.warn(`Error setting effect param ${effectType}.${paramKey}:`, effectError);
                }
              });
            }
          });
        }
        
        console.log('Preset applied successfully');
      } catch (error) {
        console.error('Error applying preset:', error);
      }
    }
  };

  // Define chord voicings for each mode with bass notes
  const chordVoicings = {
    'C': [48, 60, 64, 67, 71],  // Cmaj7 (I) - C bass
    'D': [50, 62, 65, 69, 72],  // Dmin7 (ii) - D bass
    'E': [52, 64, 67, 71, 74],  // Emin7 (iii) - E bass
    'F': [53, 65, 69, 72, 76],  // Fmaj7 (IV) - F bass
    'G': [55, 67, 71, 74, 77],  // G7sus4 (V) - G bass
    'A': [57, 69, 72, 76, 79],  // Amin7 (vi) - A bass
    'B': [59, 71, 74, 77, 80]   // Bm7b5 (viiø) - B bass
  };

  // Define Roman numerals and chord names
  const chordInfo = {
    'C': { numeral: 'I', name: 'Cmaj7' },
    'D': { numeral: 'ii', name: 'Dmin7' },
    'E': { numeral: 'iii', name: 'Emin7' },
    'F': { numeral: 'IV', name: 'Fmaj7' },
    'G': { numeral: 'V', name: 'G7sus4' },
    'A': { numeral: 'vi', name: 'Amin7' },
    'B': { numeral: 'viiø', name: 'Bm7b5' }
  };

  // Get chord color based on chord name
  const getChordColor = (chordName) => {
    const colors = {
      'C': '#8A2BE2',  // Purple
      'D': '#7B42E5',  // Purple-blue
      'E': '#6C5AE8',  // Blue-purple
      'F': '#4B7BE8',  // Blue
      'G': '#20A4E8',  // Light blue
      'A': '#20C5D5',  // Teal
      'B': '#20D5CB'   // Turquoise
    };
    return colors[chordName] || '#6C63FF';
  };

  // Play a chord
  const playSound = async (chordName, event) => {
    try {
      // Ensure audio context is started
      if (Tone.context.state !== 'running') {
        try {
          await Tone.start();
          console.log('Audio context started before playing sound');
          setAudioContextStarted(true);
        } catch (error) {
          console.error('Error starting audio context:', error);
          return; // Exit if we can't start audio context
        }
      }
      
      // Stop any currently playing notes before playing new ones
      if (activeNotes.length > 0) {
        console.log('Releasing previous notes before playing new chord');
        
        // Release notes on internal synth
        if (synth && selectedSynth !== 'internal' && !synth._disposed) {
          try {
            if (typeof synth.releaseAll === 'function') {
              synth.releaseAll();
            } else if (synth.triggerRelease && Array.isArray(activeNotes)) {
              const validActiveNotes = activeNotes.filter(note => 
                typeof note === 'number' && Number.isFinite(note) && !isNaN(note)
              );
              
              if (validActiveNotes.length > 0) {
                const freqNotes = validActiveNotes
                  .map(note => midiToFreq(note))
                  .filter(freq => typeof freq === 'number' && Number.isFinite(freq));
                
                if (freqNotes.length > 0) {
                  synth.triggerRelease(freqNotes);
                }
              }
            }
          } catch (error) {
            console.warn('Error releasing previous notes:', error);
          }
        }
        
        // Release MIDI notes
        if (midiOutput && selectedSynth === 'internal') {
          try {
            // Send note off for active notes
            activeNotes.forEach(note => {
              if (typeof note === 'number' && note >= 0 && note <= 127) {
                if (midiOutput.send) {
                  // Note off message (0x80 + channel, note, velocity 0)
                  midiOutput.send([0x80, note, 0]);
                }
              }
            });
          } catch (error) {
            console.warn('Error releasing MIDI notes:', error);
          }
        }
      }
      
      if (!chordName || !effectsChainRef.current) {
        console.warn('Missing chord name or effects chain');
        return;
      }
      
      // Get chord voicing
      const chord = chordVoicings[chordName] || [];
      if (chord.length === 0) {
        console.warn('No chord voicing found for', chordName);
        return;
      }
      
      // Apply optimal voice leading if we have previous notes
      const voiced = previousNotes ? findOptimalVoicing(previousNotes, chord) : chord;
      
      // Store the voiced notes for next time
      setPreviousNotes(voiced);
      
      // Convert MIDI notes to frequencies for synthesizers
      // Strictly validate MIDI notes: must be a number between 0-127
      const validMidiNotes = voiced.filter(note => 
        typeof note === 'number' && 
        Number.isFinite(note) && 
        !isNaN(note) && 
        note >= 0 && 
        note <= 127
      );
      
      // If we filtered out all notes, exit early
      if (validMidiNotes.length === 0) {
        console.warn('No valid MIDI notes to play for chord:', chordName);
        return;
      }
      
      // Convert to frequencies for synth playback - validate after conversion too
      const freqNotes = validMidiNotes
        .map(note => midiToFreq(note))
        .filter(freq => typeof freq === 'number' && Number.isFinite(freq) && !isNaN(freq));
      
      if (freqNotes.length === 0) {
        console.warn('No valid frequency notes after conversion');
        return;
      }
      
      console.log(`Chord ${chordName}:`, freqNotes);

      if (selectedSynth === 'internal') {
        // Send MIDI chord to external device
        if (midiOutput) {
          try {
            sendMIDIChord(midiOutput, validMidiNotes);
          } catch (error) {
            console.error('Error sending MIDI chord:', error);
          }
        } else {
          console.warn('No MIDI output available for "internal" synth');
        }
      } else if (synth) {
        try {
          // Check if the synth is in a valid state
          if (!synth || synth._disposed) {
            console.warn('Cannot trigger already disposed or null synth');
            return;
          }

          // Special handling for padsynth
          if (selectedSynth === 'padsynth' && synth.voices) {
            // Pad synth has a custom triggerAttack method
            if (typeof synth.triggerAttack === 'function') {
              try {
                synth.triggerAttack(freqNotes);
                console.log('Triggered pad synth with custom method');
              } catch (triggerError) {
                console.error('Error using padsynth custom trigger:', triggerError);
                // Try fallback if main method fails
                console.warn('Attempting fallback method for pad synth voices');
                triggerPadSynthVoicesIndividually(freqNotes);
              }
            } else {
              // Fallback method for individual voices
              console.log('Using fallback method for padsynth voices');
              triggerPadSynthVoicesIndividually(freqNotes);
            }
          } else {
            // Regular PolySynth/FMSynth
            console.log(`Triggering ${selectedSynth} with ${freqNotes.length} notes`);
            synth.triggerAttack(freqNotes);
          }
        } catch (error) {
          console.error('Error triggering synth:', error);
        }
      } else {
        console.warn('No synth available');
      }

      // Set active notes for UI feedback
      setActiveNotes([...validMidiNotes]);

      // Display chord info and effect
      const chordDisplayName = chordInfo[chordName]?.name || chordName;
      const chordNumeral = chordInfo[chordName]?.numeral || '';
      console.log(`Playing ${chordDisplayName} (${chordNumeral})`);
      
      // Calculate button position for particle effect
      let containerPosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      
      // Try to get position from the synthesizer container for more accurate positioning
      const synthContainer = document.querySelector('.synthesizer-container');
      if (synthContainer) {
        const rect = synthContainer.getBoundingClientRect();
        containerPosition = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
      }

      // If the event has a target, use that position instead
      if (event && event.currentTarget) {
        const rect = event.currentTarget.getBoundingClientRect();
        containerPosition = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
      }

      // Get a chord color for the effect
      const chordColor = getChordColor(chordName);
      setParticleProps({
        active: true,
        position: containerPosition,
        color: chordColor,
        mode: 'ambient'
      });
    } catch (error) {
      console.error('Unexpected error in playSound:', error);
    }
  };
  
  // Helper function for triggering pad synth voices individually
  const triggerPadSynthVoicesIndividually = (freqNotes) => {
    if (!synth || !synth.voices) return;
    
    try {
      // Only use a subset of notes for each voice to avoid overloading
      const voice1Notes = freqNotes.slice(0, Math.min(4, freqNotes.length));
      
      Object.entries(synth.voices).forEach(([voiceName, voice], index) => {
        if (!voice || typeof voice.triggerAttack !== 'function') {
          console.warn(`Voice ${voiceName} not available or missing triggerAttack`);
          return;
        }
        
        try {
          if (index === 0 && voice1Notes.length > 0) {
            // First voice gets main notes
            voice.triggerAttack(voice1Notes);
            console.log(`Triggered ${voiceName} with ${voice1Notes.length} notes`);
          } else if (index === 1 && freqNotes.length > 0) {
            // Second voice gets high notes (doubled octave)
            const highNotes = freqNotes
              .map(f => f * 2)
              .filter(freq => Number.isFinite(freq) && !isNaN(freq));
            
            if (highNotes.length > 0) {
              voice.triggerAttack(highNotes);
              console.log(`Triggered ${voiceName} with high notes`);
            }
          } else if (index === 2 && freqNotes.length > 0) {
            // Third voice gets the root note (bass)
            const bassNote = freqNotes[0] / 2;
            if (Number.isFinite(bassNote) && !isNaN(bassNote)) {
              voice.triggerAttack(bassNote);
              console.log(`Triggered ${voiceName} with bass note`);
            }
          } else if (freqNotes.length > 0) {
            // Other voices share the notes
            voice.triggerAttack(freqNotes);
            console.log(`Triggered ${voiceName} with all notes`);
          }
        } catch (voiceError) {
          console.warn(`Error triggering voice ${voiceName}:`, voiceError);
        }
      });
    } catch (error) {
      console.error('Error in triggerPadSynthVoicesIndividually:', error);
    }
  };

  // Stop all notes
  const stopAllNotes = async (event) => {
    try {
      // Ensure audio context is started
      if (Tone.context.state !== 'running') {
        try {
          await Tone.start();
          console.log('Audio context started before stopping sound');
          setAudioContextStarted(true);
        } catch (error) {
          console.error('Error starting audio context:', error);
          return; // Exit if we can't start audio context
        }
      }
      
      console.log('Stopping all notes for synth type:', selectedSynth);
      
      // Release all notes for internal synths
      if (synth && selectedSynth !== 'internal') {
        try {
          // Check if the synth is disposed before attempting to release notes
          if (!synth || synth._disposed) {
            console.warn('Cannot release notes on disposed or null synth');
          } else {
            // Special handling for pad synth
            if (selectedSynth === 'padsynth' && synth.voices) {
              try {
                // First try the main releaseAll method
                if (typeof synth.releaseAll === 'function') {
                  synth.releaseAll();
                  console.log('Released all pad synth notes using releaseAll');
                } else {
                  // Try to release each voice individually
                  stopPadSynthVoicesIndividually();
                }
              } catch (releaseError) {
                console.warn('Error using main releaseAll method:', releaseError);
                // Try individual voices as a backup
                stopPadSynthVoicesIndividually();
              }
            } else if (typeof synth.releaseAll === 'function') {
              // Regular synth with releaseAll method
              synth.releaseAll();
              console.log('Released all synth notes');
            } else if (synth.triggerRelease && Array.isArray(activeNotes) && activeNotes.length > 0) {
              // If releaseAll is not available but we have activeNotes, release them specifically
              const validActiveNotes = activeNotes.filter(note => 
                typeof note === 'number' && 
                Number.isFinite(note) && 
                !isNaN(note) && 
                note >= 0 && 
                note <= 127
              );
              
              if (validActiveNotes.length > 0) {
                const freqNotes = validActiveNotes
                  .map(note => midiToFreq(note))
                  .filter(freq => typeof freq === 'number' && Number.isFinite(freq) && !isNaN(freq));
                  
                if (freqNotes.length > 0) {
                  synth.triggerRelease(freqNotes);
                  console.log(`Released ${freqNotes.length} specific synth notes`);
                } else {
                  console.warn('No valid frequency notes to release');
                }
              } else {
                console.warn('No valid active notes to release');
              }
            } else {
              console.warn('Could not find a way to release synth notes');
            }
          }
        } catch (error) {
          console.error('Error releasing synth notes:', error);
        }
      }
      
      // Stop MIDI notes for external devices
      if (midiOutput && selectedSynth === 'internal') {
        try {
          allNotesOff(midiOutput);
          console.log('Sent MIDI all notes off message');
        } catch (error) {
          console.error('Error sending MIDI all notes off:', error);
        }
      }
      
      // Clear active notes for UI feedback
      setActiveNotes([]);
      setPreviousNotes(null); // Reset previous notes for voice leading
      console.log('All notes stopped');
      
      // Update particle effect to stop particles with a fade-out
      setParticleProps(prev => ({ 
        ...prev, 
        active: false,
        // Retain the last color and position for a smooth fade-out
        color: prev.color,
        position: prev.position
      }));
    } catch (error) {
      console.error('Unexpected error in stopAllNotes:', error);
    }
  };

  // Helper function to stop pad synth voices individually
  const stopPadSynthVoicesIndividually = () => {
    if (!synth || !synth.voices) return;
    
    console.log('Releasing individual pad synth voices');
    Object.entries(synth.voices).forEach(([voiceName, voice]) => {
      try {
        if (!voice) {
          console.warn(`Voice ${voiceName} is null or undefined`);
          return;
        }
        
        if (typeof voice.releaseAll === 'function') {
          voice.releaseAll();
          console.log(`Released ${voiceName} notes using releaseAll`);
        } else if (typeof voice.triggerRelease === 'function' && Array.isArray(activeNotes)) {
          // Try to release specific notes if we have them
          const validActiveNotes = activeNotes.filter(note => 
            typeof note === 'number' && 
            Number.isFinite(note) && 
            !isNaN(note) && 
            note >= 0 && 
            note <= 127
          );
          
          if (validActiveNotes.length > 0) {
            const freqNotes = validActiveNotes
              .map(note => midiToFreq(note))
              .filter(freq => typeof freq === 'number' && Number.isFinite(freq) && !isNaN(freq));
              
            if (freqNotes.length > 0) {
              try {
                voice.triggerRelease(freqNotes);
                console.log(`Released ${voiceName} specific notes`);
              } catch (releaseError) {
                // Last resort: try to release without specific notes
                console.warn(`Error releasing specific notes for ${voiceName}:`, releaseError);
                if (typeof voice.triggerRelease === 'function') {
                  try {
                    voice.triggerRelease();
                    console.log(`Released ${voiceName} using parameterless triggerRelease`);
                  } catch (fallbackError) {
                    console.error(`Failed all release attempts for ${voiceName}:`, fallbackError);
                  }
                }
              }
            } else {
              console.warn(`No valid frequency notes to release for ${voiceName}`);
              // Try parameterless release as fallback
              if (typeof voice.triggerRelease === 'function') {
                try {
                  voice.triggerRelease();
                  console.log(`Released ${voiceName} using parameterless triggerRelease`);
                } catch (releaseError) {
                  console.warn(`Error with parameterless release for ${voiceName}:`, releaseError);
                }
              }
            }
          } else {
            console.warn(`No valid active notes to release for ${voiceName}`);
            // Try parameterless release as fallback
            if (typeof voice.triggerRelease === 'function') {
              try {
                voice.triggerRelease();
                console.log(`Released ${voiceName} using parameterless triggerRelease`);
              } catch (releaseError) {
                console.warn(`Error with parameterless release for ${voiceName}:`, releaseError);
              }
            }
          }
        } else {
          console.warn(`No way to release notes for ${voiceName}`);
        }
      } catch (voiceError) {
        console.warn(`Error releasing ${voiceName}:`, voiceError.message);
      }
    });
  };

  // Unified stop function - combines stopping sequence and all notes
  const stopAll = async () => {
    // First stop any running sequence
    if (sequenceRef.current) {
      clearInterval(sequenceRef.current);
      sequenceRef.current = null;
    }
    
    // Then stop all notes
    await stopAllNotes();
    
    console.log('Stopped all sequences and notes');
  };

  // Find and update the original stopChordSequence function around line 889
  const stopChordSequence = () => {
    // Clear chord sequence interval
    if (sequenceRef.current) {
      clearInterval(sequenceRef.current);
      sequenceRef.current = null;
    }
    
    // Clear pattern playback interval
    if (patternPlaybackRef.current) {
      clearInterval(patternPlaybackRef.current);
      patternPlaybackRef.current = null;
      setPatternPlaybackPosition(-1);
    }
    
    // Stop all sounds
    stopAllNotes();
    setIsPlayingSequence(false);
    setCurrentSequenceIndex(-1);
  };

  // Handle timeline update
  const handleTimelineUpdate = (updatedSlots) => {
    setTimelineChords(updatedSlots);
  };

  // Play the chord sequence from the timeline
  const playChordSequence = async () => {
    if (isPlayingSequence) {
      // Stop the sequence if already playing
      stopChordSequence();
      return;
    }

    // Check if there are any chords in the timeline
    const validChords = timelineChords.filter(chord => chord !== null);
    if (validChords.length === 0) {
      alert("Please add at least one chord to your progression first!");
      return;
    }

    setIsPlayingSequence(true);
    setCurrentSequenceIndex(0);

    // Create a sequencer to play through the chords
    const chordInterval = 2000; // 2 seconds per chord
    
    // Play the first chord immediately
    if (timelineChords[0]) {
      // Use the chord's note property (root note) for playSound, not the full name
      console.log("Playing chord:", timelineChords[0].name, "using root note:", timelineChords[0].note);
      playSound(timelineChords[0].note);
    }

    // Set up sequencer to play the rest of the chords
    let currentIndex = 1;
    
    sequenceRef.current = setInterval(() => {
      // Stop all previous notes before playing the next one
      stopAllNotes();

      // Play the current chord if it exists
      if (currentIndex < timelineChords.length && timelineChords[currentIndex]) {
        // Use the chord's note property (root note) for playSound, not the full name
        console.log("Playing chord:", timelineChords[currentIndex].name, "using root note:", timelineChords[currentIndex].note);
        playSound(timelineChords[currentIndex].note);
        setCurrentSequenceIndex(currentIndex);
      }

      currentIndex++;

      // When chord progression is done, play the piano roll pattern
      if (currentIndex >= timelineChords.length) {
        setTimeout(() => {
          // Only play pattern if there are notes
          if (pianoRollNotes && pianoRollNotes.length > 0) {
            playPianoRollPattern();
          } else {
            stopChordSequence();
            setCurrentSequenceIndex(-1); // Reset the current index
          }
        }, chordInterval - 100);
      }
    }, chordInterval);
  };

  // Prepare chord bank data for the ChordBank component
  const chordBankData = Object.keys(chordVoicings).map(note => ({
    note,
    name: chordInfo[note].name
  }));

  // Handle piano roll notes change
  const handlePianoRollNotesChange = (updatedNotes) => {
    setPianoRollNotes(updatedNotes);
  };

  // Add a function to clear all notes from the piano roll
  const clearAllNotes = () => {
    setPianoRollNotes([]);
    if (handlePianoRollNotesChange) {
      handlePianoRollNotesChange([]);
    }
  };

  // Function to play a specific note with the regular synth
  const playNote = (noteName) => {
    if (!synth || !noteName) return;
    
    try {
      // Extract pitch class and octave (e.g., "C4" -> "C" and 4)
      const pitchClass = noteName.substring(0, noteName.length - 1);
      const octave = parseInt(noteName.substring(noteName.length - 1));
      
      // Convert to frequency
      const frequency = Tone.Frequency(`${pitchClass}${octave}`).toFrequency();
      
      // Play the note
      synth.triggerAttackRelease(frequency, "8n");
      
      // Set particle effect
      setParticleProps({
        active: true,
        position: { x: Math.random() * 500, y: Math.random() * 300 },
        color: getChordColor(pitchClass),
        mode: 'note'
      });
      
      // Reset particle effect after a delay
      setTimeout(() => {
        setParticleProps({
          active: false,
          position: { x: 0, y: 0 },
          color: '#6C63FF',
          mode: 'ambient'
        });
      }, 500);
      
    } catch (error) {
      console.error("Error playing note:", error);
    }
  };
  
  // Function to play a note with the lead synth
  const playNoteWithLeadSynth = (noteName) => {
    if (!leadSynth || !noteName) return;
    
    try {
      // Extract pitch class and octave (e.g., "C4" -> "C" and 4)
      const pitchClass = noteName.substring(0, noteName.length - 1);
      const octave = parseInt(noteName.substring(noteName.length - 1));
      
      // Convert to frequency
      const frequency = Tone.Frequency(`${pitchClass}${octave}`).toFrequency();
      
      // Play the note with the lead synth
      leadSynth.triggerAttackRelease(frequency, "8n");
      
      // Set particle effect
      setParticleProps({
        active: true,
        position: { x: Math.random() * 500, y: Math.random() * 300 },
        color: getChordColor(pitchClass),
        mode: 'note'
      });
      
      position: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
      color: '#FF8E53',
      mode: 'burst'
    });
    
    // Turn off particles after a short delay
    setTimeout(() => {
      setParticleProps({
        active: false,
        position: { x: 0, y: 0 },
        color: '#6C63FF',
        mode: 'ambient'
      });
    }, 800);
  };

  // Generate a random song name
  const generateRandomSongName = () => {
    // Arrays of words to create song names
    const adjectives = [
      'Ethereal', 'Midnight', 'Crystal', 'Electric', 'Velvet', 'Lunar', 'Neon', 
      'Silver', 'Golden', 'Cosmic', 'Digital', 'Dreamy', 'Mystic', 'Distant',
      'Ambient', 'Resonant', 'Silent', 'Whispered', 'Chromatic', 'Harmonic'
    ];
    
    const nouns = [
      'Wave', 'Dream', 'Echo', 'Journey', 'Horizon', 'Symphony', 'Memory',
      'Pulse', 'Cascade', 'Voyage', 'Shadow', 'Rhythm', 'Harmony', 'Melody',
      'Vision', 'Oasis', 'Mirage', 'Reverie', 'Sanctuary', 'Atmosphere'
    ];
    
    // Pick random words
    const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    
    // Create song name with format "Adjective Noun"
    const songName = `${adjective} ${noun}`;
    
    // Update the state
    setSongName(songName);
  };

  // Handle song name input change
  const handleSongNameChange = (event) => {
    setSongName(event.target.value);
  };

  // Handle track name input change
  const handleTrackNameChange = (event) => {
    setTrackName(event.target.value);
  };

  // Generate a random track name
  const generateRandomTrackName = () => {
    // Arrays of words to create track names
    const instruments = [
      'Piano', 'Synth', 'Strings', 'Bass', 'Guitar', 'Drums', 'Pad', 
      'Lead', 'Keys', 'Bells', 'Arpeggio', 'Vocal', 'Brass', 'Flute',
      'Chords', 'Melody', 'Beat', 'FX', 'Texture', 'Ambience'
    ];
    
    const descriptors = [
      'Main', 'Ambient', 'Pulsing', 'Deep', 'Dreamy', 'Smooth', 'Dark',
      'Bright', 'Ethereal', 'Floating', 'Driving', 'Lush', 'Sparse', 'Rich',
      'Glitchy', 'Warm', 'Cool', 'Soft', 'Punchy', 'Atmospheric'
    ];
    
    // Pick random words - sometimes use just the instrument, sometimes with descriptor
    const useDescriptor = Math.random() > 0.3; // 70% chance to use descriptor
    const instrument = instruments[Math.floor(Math.random() * instruments.length)];
    
    let trackName;
    
    if (useDescriptor) {
      const descriptor = descriptors[Math.floor(Math.random() * descriptors.length)];
      trackName = `${descriptor} ${instrument}`;
    } else {
      trackName = instrument;
    }
    
    // Update the state
    setTrackName(trackName);
  };

  // Generate melody based on chord progression
  const generateMelody = () => {
    // If no chord progression, do nothing
    if (!timelineChords.some(chord => chord !== null)) {
      alert("Please create a chord progression first!");
      return;
    }
    
    // Determine mode based on the chord progression
    const mode = determineMode(timelineChords);
    
    // Determine root note (tonic) based on first chord or most common root
    const validChords = timelineChords.filter(chord => chord !== null);
    const firstChord = validChords[0];
    const tonic = firstChord.note.replace(/[0-9]/g, ''); // Remove octave number
    
    console.log(`Detected mode: ${mode} with tonic: ${tonic}`);
    
    // Get scale notes
    const scaleNotes = getScaleNotes(tonic, mode);
    console.log("Scale notes:", scaleNotes);
    
    // Generate a melody
    const generatedNotes = [];
    let noteId = 1;
    
    // For each bar (chord slot)
    for (let barIndex = 0; barIndex < 4; barIndex++) {
      const chord = timelineChords[barIndex];
      if (!chord) continue;
      
      // Get notes for this chord
      const chordNotesNoOctave = getChordNotes(chord.name);
      console.log(`Chord ${chord.name} notes:`, chordNotesNoOctave);
      
      // Determine octave range (for variety)
      const octave = barIndex % 2 === 0 ? 4 : 3;
      
      // Define start positions for notes within this bar (in sixteenth notes)
      // 16 sixteenth notes per bar
      const startPositions = barIndex === 0 
        ? [0, 4, 8, 12] // First bar pattern
        : barIndex === 1
          ? [0, 2, 4, 8, 12] // Second bar pattern
          : barIndex === 2
            ? [0, 3, 6, 9, 12, 14] // Third bar pattern
            : [0, 2, 4, 6, 8, 10, 12, 14]; // Fourth bar pattern (more notes)
      
      // Generate notes for this bar
      startPositions.forEach((startPos, index) => {
        // Alternate between chord tones and scale tones
        const useChordTone = index % 2 === 0 || Math.random() < 0.7; // Favor chord tones
        
        let noteBase;
        if (useChordTone) {
          // Use chord tone
          noteBase = chordNotesNoOctave[index % chordNotesNoOctave.length];
        } else {
          // Use scale tone
          noteBase = scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
        }
        
        // Adjust octave for higher notes occasionally
        const noteOctave = Math.random() < 0.2 ? octave + 1 : octave;
        
        // Create the note
        generatedNotes.push({
          id: noteId++,
          noteName: `${noteBase}${noteOctave}`,
          startBeat: barIndex * 16 + startPos, // 16 sixteenth notes per bar
          duration: Math.random() < 0.3 ? 2 : 1 // Occasional longer notes
        });
      });
    }
    
    // Update piano roll with generated notes
    setPianoRollNotes(generatedNotes);
    if (handlePianoRollNotesChange) {
      handlePianoRollNotesChange(generatedNotes);
    }
    
    console.log("Generated melody notes:", generatedNotes);
  };

  // Custom component to ensure progression and piano roll alignment
  const AlignedProgressionAndPianoRoll = () => {
    // Define a variable for the piano roll config for reference
    const pianoRollConfig = {
      keyWidth: 60,
      barCount: 4
    };
    
    // Calculate exact position to align with piano roll
    const contentWidth = `calc(100% - ${pianoRollConfig.keyWidth}px)`;
    
    return (
      <div style={{ 
        width: '100%', 
        maxWidth: '768px', 
        margin: '0 auto',
        position: 'relative' 
      }}>
        {/* Combined controls for both progression and piano roll */}
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '10px',
          padding: '0 10px'
        }}>
          <div style={{ 
            fontSize: '1.1rem', 
            fontWeight: 'bold', 
            color: 'rgba(255, 255, 255, 0.8)' 
          }}>
            Pattern Editor
          </div>
          
          <div style={{ display: 'flex', gap: '10px' }}>
            <button
              onClick={generateMelody}
              style={{
                padding: '6px 14px',
                background: 'linear-gradient(90deg, #FF6B6B, #FFD166)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 1px 3px rgba(0, 0, 0, 0.3)'
              }}
            >
              <span style={{ fontSize: '0.8rem' }}>✨</span> Generate Melody
            </button>
            
            <button
              onClick={playChordSequence}
              disabled={isPlayingSequence}
              style={{
                padding: '6px 14px',
                background: isPlayingSequence ? 'rgba(108, 99, 255, 0.3)' : 'linear-gradient(90deg, #6C63FF, #4ECDC4)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                fontWeight: 'bold',
                cursor: isPlayingSequence ? 'not-allowed' : 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 1px 3px rgba(0, 0, 0, 0.3)'
              }}
            >
              <span style={{ fontSize: '0.8rem' }}>▶</span> Play
            </button>
            
            <button
              onClick={stopChordSequence}
              style={{
                padding: '6px 14px',
                background: isPlayingSequence ? '#FF3366' : 'rgba(255, 51, 102, 0.3)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                fontWeight: 'bold',
                cursor: isPlayingSequence ? 'pointer' : 'not-allowed',
                opacity: isPlayingSequence ? 1 : 0.7,
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 1px 3px rgba(0, 0, 0, 0.3)'
              }}
            >
              <span style={{ fontSize: '0.8rem' }}>■</span> Stop
            </button>
          </div>
        </div>
        
        {/* Container for integrated progression and piano roll */}
        <div style={{ position: 'relative' }}>
          {/* Progression timeline directly above piano roll */}
          <div style={{ position: 'relative', display: 'flex' }}>
            {/* Blank space matching piano key width */}
            <div style={{ 
              width: `${pianoRollConfig.keyWidth}px`,
              height: '25px',
              backgroundColor: '#1f1f2f',
              borderRight: '1px solid rgba(255, 255, 255, 0.2)'
            }}></div>
            
            {/* Progression slots */}
            <div style={{ 
              display: 'flex',
              width: contentWidth,
              height: '25px'
            }}>
              {timelineChords.map((chord, index) => (
                <div 
                  key={index} 
                  style={{
                    width: '25%',
                    height: '100%',
                    backgroundColor: chord ? getChordColor(chord.note) : 'rgba(30, 30, 40, 0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: 'white',
                    fontWeight: 'bold',
                    fontSize: '0.9rem',
                    borderBottom: '1px solid rgba(50, 50, 60, 0.8)',
                    borderRight: index < 3 ? '1px solid rgba(255, 255, 255, 0.2)' : 'none',
                    boxShadow: currentSequenceIndex === index 
                      ? '0 0 10px rgba(255, 255, 255, 0.3)' 
                      : 'none'
                  }}
                >
                  {chord ? chord.name : '-'}
                </div>
              ))}
            </div>
          </div>
          
          {/* Piano Roll right below the progression */}
          <PianoRoll
            onNotesChange={handlePianoRollNotesChange}
            onNotePlay={playNoteWithLeadSynth}
            initialNotes={pianoRollNotes}
          />
          
          {/* Clear All Notes button below Piano Roll */}
          <div style={{ 
            display: 'flex', 
            justifyContent: 'center', 
            marginTop: '15px'
          }}>
            <button
              onClick={clearAllNotes}
              style={{
                padding: '6px 14px',
                background: 'linear-gradient(90deg, #8A2BE2, #1E90FF)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                fontWeight: 'bold',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '5px',
                boxShadow: '0 1px 3px rgba(0, 0, 0, 0.3)'
              }}
            >
              <span style={{ fontSize: '0.8rem' }}>🧹</span> Clear All Notes
            </button>
          </div>
        </div>
      </div>
    );
  };

  // Wizard step content rendering
  const renderWizardStepContent = () => {
    switch (wizardStep) {
      case 1: // Song Creation
        return (
          <div className="wizard-step">
            <div className="wizard-step-header">
              <h3>Step 1: Song Creation</h3>
              <p>Start your creative journey by naming your musical piece.</p>
            </div>
            
            <div className="wizard-form">
              <div className="form-group">
                <label htmlFor="song-name">Song Name</label>
                <div className="input-with-button">
                  <input 
                    type="text" 
                    id="song-name" 
                    value={songName}
                    onChange={handleSongNameChange}
                    placeholder="Enter a name for your song"
                    autoFocus
                  />
                  <button 
                    onClick={generateRandomSongName}
                    className="generate-name-button"
                    title="Generate a random song name"
                  >
                    <span>✨</span>
                  </button>
                </div>
                <div className="form-hint">
                  This will be the title of your musical creation
                </div>
              </div>
              
              <div className="form-illustration">
                <div className="illustration-icon">🎵</div>
                <div className="illustration-text">
                  Every great piece of music starts with a name. What will you call yours?
                </div>
              </div>
            </div>
            
            <div className="wizard-navigation">
              <button 
                onClick={nextWizardStep}
                disabled={!isStepReady()}
                className={`wizard-next-button ${!isStepReady() ? 'disabled' : ''}`}
              >
                Continue to Chord Progression <span>→</span>
              </button>
            </div>
          </div>
        );
      
      case 2: // Progression (now before Track)
        return (
          <div className="wizard-step">
            <div className="wizard-step-header">
              <h3>Step 2: Chord Progression</h3>
              <p>Create the harmonic foundation for your song "{songName}".</p>
            </div>
            
            {/* Play/Stop and Generate Buttons above timeline */}
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              width: '100%', 
              maxWidth: '750px',
              marginBottom: '10px'
            }}>
              <div style={{ fontSize: '1.1rem', fontWeight: 'bold', color: 'rgba(255, 255, 255, 0.8)' }}>
                Chord Sequence
              </div>
              <div style={{ display: 'flex', gap: '10px' }}>
                <button
                  onClick={generateRandomProgression}
                  style={{
                    padding: '8px 15px',
                    background: 'linear-gradient(90deg, #FF8E53, #FE6B8B)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    fontWeight: 'bold',
                    cursor: 'pointer',
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '5px'
                  }}
                >
                  <span style={{ fontSize: '0.8rem' }}>✨</span> Generate
                </button>
                <button
                  onClick={playChordSequence}
                  disabled={isPlayingSequence || !timelineChords.some(chord => chord !== null)}
                  style={{
                    padding: '8px 15px',
                    background: isPlayingSequence ? 'rgba(108, 99, 255, 0.3)' : 'linear-gradient(90deg, #6C63FF, #4ECDC4)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    fontWeight: 'bold',
                    cursor: isPlayingSequence || !timelineChords.some(chord => chord !== null) ? 'not-allowed' : 'pointer',
                    opacity: isPlayingSequence || !timelineChords.some(chord => chord !== null) ? 0.7 : 1,
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '5px'
                  }}
                >
                  <span style={{ fontSize: '0.8rem' }}>▶</span> Play
                </button>
                <button
                  onClick={stopChordSequence}
                  style={{
                    padding: '8px 15px',
                    background: isPlayingSequence ? '#FF3366' : 'rgba(255, 51, 102, 0.3)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    fontWeight: 'bold',
                    cursor: isPlayingSequence ? 'pointer' : 'not-allowed',
                    opacity: isPlayingSequence ? 1 : 0.7,
                    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '5px'
                  }}
                >
                  <span style={{ fontSize: '0.8rem' }}>■</span> Stop
                </button>
              </div>
            </div>
            
            {/* Timeline Component */}
            <Timeline 
              onTimelineUpdate={handleTimelineUpdate} 
              isPlaying={isPlayingSequence}
              currentSlotIndex={currentSequenceIndex}
              initialSlots={timelineChords}
            />
            
            {/* Chord Bank */}
            <ChordBank 
              chordBank={chordBankData} 
              onChordClick={playSound} 
            />
            
            <div className="wizard-navigation">
              <button onClick={prevWizardStep} className="wizard-prev-button">
                <span>←</span> Back to Song Creation
              </button>
              <button 
                onClick={nextWizardStep}
                disabled={!isStepReady()}
                className={`wizard-next-button ${!isStepReady() ? 'disabled' : ''}`}
              >
                Continue to Track Creation <span>→</span>
              </button>
            </div>
          </div>
        );
      
      case 3: // Track Creation (now after Progression)
        return (
          <div className="wizard-step">
            <div className="wizard-step-header">
              <h3>Step 3: Track Creation</h3>
              <p>Name your first instrument track within "{songName}".</p>
            </div>
            
            {/* Chord progression reminder */}
            <div className="progression-reminder">
              <div className="reminder-header">Your Progression:</div>
              <div className="reminder-chords">
                {timelineChords.map((chord, index) => (
                  <div key={index} className="reminder-chord">
                    {chord ? chord.name : '-'}
                  </div>
                ))}
              </div>
              <button
                onClick={playChordSequence}
                className="play-reminder-button"
                disabled={isPlayingSequence}
              >
                <span>▶</span> Play Progression
              </button>
            </div>
            
            <div className="wizard-form">
              <div className="form-group">
                <label htmlFor="track-name">Track Name</label>
                <div className="input-with-button">
                  <input 
                    type="text" 
                    id="track-name" 
                    value={trackName}
                    onChange={handleTrackNameChange}
                    placeholder="e.g., Piano, Melody, Bassline"
                    autoFocus
                  />
                  <button 
                    onClick={generateRandomTrackName}
                    className="generate-name-button"
                    title="Generate a random track name"
                  >
                    <span>✨</span>
                  </button>
                </div>
                <div className="form-hint">
                  Each track represents a different instrument or sound in your song
                </div>
              </div>
              
              <div className="form-illustration">
                <div className="illustration-icon">🎹</div>
                <div className="illustration-text">
                  Think of tracks like layers in your musical arrangement - they'll play together to create your full song.
                </div>
              </div>
            </div>
            
            <div className="wizard-navigation">
              <button onClick={prevWizardStep} className="wizard-prev-button">
                <span>←</span> Back to Chord Progression
              </button>
              <button 
                onClick={nextWizardStep}
                disabled={!isStepReady()}
                className={`wizard-next-button ${!isStepReady() ? 'disabled' : ''}`}
              >
                Continue to Pattern Creation <span>→</span>
              </button>
            </div>
          </div>
        );
      
      case 4: // Pattern Creation
        return (
          <div className="wizard-step">
            <div className="wizard-step-header">
              <h3>Step 4: Pattern Creation</h3>
              <p>Create a melody pattern for your "{trackName}" track in "{songName}".</p>
            </div>
            
            {/* Custom component that ensures alignment */}
            <AlignedProgressionAndPianoRoll />
            
            <div className="wizard-navigation">
              <button onClick={prevWizardStep} className="wizard-prev-button">
                <span>←</span> Back to Track Creation
              </button>
              <button 
                className="wizard-finish-button"
                onClick={() => alert(`Congratulations! You've created a song called "${songName}" with a "${trackName}" track featuring a chord progression and melody pattern.`)}
              >
                Finish <span>✓</span>
              </button>
            </div>
          </div>
        );
        
      default:
        return null;
    }
  };

  // Create a function to create the lead synth with reverb
  const createLeadSynth = () => {
    if (!effectsChain) return null;
    
    try {
      // Create a more edgy lead synth
      const newLeadSynth = new Tone.MonoSynth({
        oscillator: {
          type: "sawtooth"
        },
        envelope: {
          attack: 0.01,
          decay: 0.2,
          sustain: 0.5,
          release: 0.4
        },
        filterEnvelope: {
          attack: 0.01,
          decay: 0.2,
          sustain: 0.5,
          release: 0.4,
          baseFrequency: 3000,
          octaves: 2
        }
      }).toDestination();
      
      // Add reverb effect specifically for lead synth
      const leadReverb = new Tone.Reverb({
        decay: 2.5,
        wet: 0.4
      }).toDestination();
      
      // Connect the lead synth to reverb
      newLeadSynth.connect(leadReverb);
      
      console.log("Lead synth created successfully");
      return newLeadSynth;
    } catch (error) {
      console.error("Error creating lead synth:", error);
      return null;
    }
  };
  
  // Initialize the lead synth when component mounts and effects chain is ready
  useEffect(() => {
    if (effectsChain && audioContextStarted && !leadSynth) {
      const newLeadSynth = createLeadSynth();
      setLeadSynth(newLeadSynth);
    }
  }, [effectsChain, audioContextStarted, leadSynth]);
  
  // Add a new function to clear all notes from the piano roll
  const clearAllNotes = () => {
    setPianoRollNotes([]);
    if (handlePianoRollNotesChange) {
      handlePianoRollNotesChange([]);
    }
  };
  
  // Update stopChordSequence to also stop pattern playback
  const stopChordSequence = () => {
    // Clear chord sequence interval
    if (sequenceRef.current) {
      clearInterval(sequenceRef.current);
      sequenceRef.current = null;
    }
    
    // Clear pattern playback interval
    if (patternPlaybackRef.current) {
      clearInterval(patternPlaybackRef.current);
      patternPlaybackRef.current = null;
      setPatternPlaybackPosition(-1);
    }
    
    // Stop all sounds
    stopAllNotes();
    setIsPlayingSequence(false);
    setCurrentSequenceIndex(-1);
  };

  return (
    <div className="synthesizer-container">
      <div className="synthesizer-content">
        {!isWizardMode ? (
          // Original non-wizard layout
          <>
            <h2>Intelligent Chord Voicing Generator</h2>
            <p style={{ marginBottom: '10px' }}>
              Create lush, beautiful chords with the press of a button.
            </p>
            
            {/* Synth controls */}
            <div className="synth-controls">
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                {/* Play/Stop Buttons above timeline */}
                <div style={{ 
                  display: 'flex', 
                  justifyContent: 'space-between', 
                  width: '100%', 
                  maxWidth: '750px',
                  marginBottom: '10px'
                }}>
                  <div style={{ fontSize: '1.1rem', fontWeight: 'bold', color: 'rgba(255, 255, 255, 0.8)' }}>
                    Chord Sequence
                  </div>
                  <div style={{ display: 'flex', gap: '10px' }}>
                    <button
                      onClick={playChordSequence}
                      disabled={isPlayingSequence || !timelineChords.some(chord => chord !== null)}
                      style={{
                        padding: '8px 15px',
                        background: isPlayingSequence ? 'rgba(108, 99, 255, 0.3)' : 'linear-gradient(90deg, #6C63FF, #4ECDC4)',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        fontWeight: 'bold',
                        cursor: isPlayingSequence || !timelineChords.some(chord => chord !== null) ? 'not-allowed' : 'pointer',
                        opacity: isPlayingSequence || !timelineChords.some(chord => chord !== null) ? 0.7 : 1,
                        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '5px'
                      }}
                    >
                      <span style={{ fontSize: '0.8rem' }}>▶</span> Play
                    </button>
                    <button
                      onClick={stopChordSequence}
                      style={{
                        padding: '8px 14px',
                        background: isPlayingSequence ? '#FF3366' : 'rgba(255, 51, 102, 0.3)',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        fontWeight: 'bold',
                        cursor: isPlayingSequence ? 'pointer' : 'not-allowed',
                        opacity: isPlayingSequence ? 1 : 0.7,
                        display: 'flex',
                        alignItems: 'center',
                        gap: '5px',
                        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.3)'
                      }}
                    >
                      <span style={{ fontSize: '0.8rem' }}>■</span> Stop
                    </button>
                  </div>
                </div>
                
                {/* Timeline Component */}
                <Timeline 
                  onTimelineUpdate={handleTimelineUpdate} 
                  isPlaying={isPlayingSequence}
                  currentSlotIndex={currentSequenceIndex}
                  initialSlots={timelineChords}
                />
                
                {/* Chord Bank */}
                <ChordBank 
                  chordBank={chordBankData} 
                  onChordClick={playSound} 
                />
                
                {/* Piano Roll */}
                <PianoRoll
                  onNotesChange={handlePianoRollNotesChange}
                  onNotePlay={playNoteWithLeadSynth}
                />
              </div>
              
              {/* Synth selector */}
              <div className="selector-container" style={{ marginTop: '20px' }}>
                <SynthSelector 
                  selectedSynth={selectedSynth} 
                  onSynthChange={handleSynthChange}
                  midiOutputs={midiOutputs}
                  selectedOutput={selectedPort}
                  onOutputChange={handleMidiDeviceChange}
                  selectedPreset={selectedPreset}
                  onPresetChange={handlePresetChange}
                />
              </div>
              
              {/* Stop button moved to the bottom */}
              <div style={{ marginTop: '20px', marginBottom: '10px', display: 'flex', justifyContent: 'center' }}>
                <StopButton onStop={stopChordSequence} />
              </div>
            </div>
          </>
        ) : (
          // Wizard mode layout
          <div className="wizard-container">
            {/* Section Title and Description */}
            {sectionTitle && (
              <div style={{ 
                textAlign: 'center', 
                marginBottom: '30px',
                position: 'relative',
                zIndex: 1
              }}>
                <h2 style={{ 
                  color: '#fff', 
                  fontSize: '2.5rem', 
                  marginBottom: '20px',
                  fontWeight: 'bold'
                }}>
                  {sectionTitle}
                </h2>
                {sectionDescription && (
                  <p style={{ 
                    color: 'rgba(255, 255, 255, 0.8)', 
                    maxWidth: '800px', 
                    margin: '0 auto',
                    fontSize: '1.1rem',
                    lineHeight: '1.6'
                  }}>
                    {sectionDescription}
                  </p>
                )}
              </div>
            )}
            
            {/* Wizard progress indicator */}
            <div className="wizard-progress">
              <div 
                className={`wizard-step-indicator ${wizardStep === 1 ? 'active' : wizardStep > 1 ? 'completed' : ''} ${canNavigateToStep(1) ? 'clickable' : ''}`}
                onClick={() => goToStep(1)}
              >
                <div className="step-number">1</div>
                <div className="step-label">Song</div>
              </div>
              <div className="progress-line"></div>
              <div 
                className={`wizard-step-indicator ${wizardStep === 2 ? 'active' : wizardStep > 2 ? 'completed' : ''} ${canNavigateToStep(2) ? 'clickable' : ''}`}
                onClick={() => goToStep(2)}
              >
                <div className="step-number">2</div>
                <div className="step-label">Progression</div>
              </div>
              <div className="progress-line"></div>
              <div 
                className={`wizard-step-indicator ${wizardStep === 3 ? 'active' : wizardStep > 3 ? 'completed' : ''} ${canNavigateToStep(3) ? 'clickable' : ''}`}
                onClick={() => goToStep(3)}
              >
                <div className="step-number">3</div>
                <div className="step-label">Track</div>
              </div>
              <div className="progress-line"></div>
              <div 
                className={`wizard-step-indicator ${wizardStep === 4 ? 'active' : wizardStep > 4 ? 'completed' : ''} ${canNavigateToStep(4) ? 'clickable' : ''}`}
                onClick={() => goToStep(4)}
              >
                <div className="step-number">4</div>
                <div className="step-label">Pattern</div>
              </div>
            </div>
            
            {/* Wizard content area */}
            {renderWizardStepContent()}
            
            {/* Synth selector - hidden in wizard mode but still functional */}
            <div className="selector-container" style={{ marginTop: '20px', display: 'none' }}>
              <SynthSelector 
                selectedSynth={selectedSynth} 
                onSynthChange={handleSynthChange}
                midiOutputs={midiOutputs}
                selectedOutput={selectedPort}
                onOutputChange={handleMidiDeviceChange}
                selectedPreset={selectedPreset}
                onPresetChange={handlePresetChange}
              />
            </div>
            
            {/* Global stop button */}
            <div style={{ marginTop: '20px', marginBottom: '10px', display: 'flex', justifyContent: 'center' }}>
              <StopButton onStop={stopChordSequence} />
            </div>
          </div>
        )}
      </div>
      
      <ParticleSystem
        active={particleProps.active}
        position={particleProps.position}
        color={particleProps.color}
      />
    </div>
  );
};

export default SynthesizerContainer; 